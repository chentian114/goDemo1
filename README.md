# go 学习练习案例

### go语言特点
    * 1.静态类型、编译型的开源语言
    * 2.脚本化的语法，支持多种编程范式（函数式&面向对象）
    * 3.原生、给力的并发编程支持

### go语言的优劣势
    * 优势
    * 1.脚本化的语法
    * 2.静态类型+编译型，程序运行速度有保障
    * 3.原生的扶持并发编程（降低开发、维护成本；程序可以更好的执行）
    * 劣势
    * 1.语法糖并没有Python和Ruby那么多
    * 2.目前的程序运行速度还不及C（已超过C++和Java）
    * 3.第三方函数库暂时不像绝对主流的编程语言那么多

### go源码文件
    * .go为后缀，内容以go语言代码组织的文件

### go源码文件分类
    * 1.命令源码文件（声明自己属于main代码包、包含无参数声明和结果声明的main函数）
        同一个代码包中强烈不建议直接包含多个命令源码文件
    * 2.库源码文件（不具备命令源码文件两个特征的源码文件）
    * 3.测试源码文件（不具备命令源码文件两个特征的源码文件，名称以_test.go为后缀）
        测试函数以Test（功能测试函数）或Benchmark为前缀（性能测试函数）

### 代码包的作用
    * 编译和归档go程序的最基本单位
    * 代码划分、集结和依赖的有效组织形式，也是权限控制的辅助手段

### 程序实体与关键字
    * 在go语言中，变量、常量、函数、结构体和接口被统称为“程序实体”，而它们的名字被统称为“标识符”。
    * 标识符可以是任何Unicode编码可以表示的字母、数字及下划线。首字母不能是数字或下划线。
    * 对程序实体的访问权限控制只能通过它们的名字来实现。名字首字母大写的程序实体可以被任何代码包访问到。而名字首字母小写的程序实体则只能被同一个代码包中的代码所访问。
    * 关键字不能作为标识符。

### 变量和常量
    * 声明变量的关键字var，声明常量的关键字const。
    * 常量只能被赋予基本数据类型的值本身。
    * var num1 int = 1  // 普通赋值： var、变量名称、变量类型、=、变量值
    * var num2,num3 int = 2,3 //平行赋值
    * var (
    *     num4 int = 4
    *     num5 int = 5
    * ) // 多行赋值
    * 上述三种赋值也适用于常量，常量不能只声明不赋值。

### 浮点数类型
    * 浮点数类型有两个，即float32和float64。存储这两个类型的值的空间分别需要4个字节和8个字节。
    * 浮点数类型的值一般由整数部分、小数点“.”和小数部分组成。
    * 指数部分由“E”或“e”以及一个带正负号的10进制数组成。比如，3.7E-2表示浮点数0.037。又比如，3.7E+1表示浮点数37
    * 有一点需要注意，在Go语言里，浮点数的相关部分只能由10进制表示法表示，而不能由8进制表示法或16进制表示法表示。

### 数组
    * 一个数组（Array）就是一个可以容纳若干类型相同的元素的容器。这个容器的大小（即数组的长度）是固定的，且是体现在数组的类型字面量之中的。
    * type MyNumbers [3]int  注：类型声明语句由关键字type、类型名称和类型字面量组成。用于表示某个类型的值的字面表示可被称为值字面量
    * var numbers = [3]int{1, 2, 3} 这是一条变量声明语句。它在声明变量的同时为该变量赋值。
    * var numbers = [...]int{1, 2, 3} 在其中的类型字面量中省略代表其长度的数字
    * numbers[0] // 会得到第一个元素
    * var length = len(numbers)  len是Go语言的内建函数的名称。该函数用于获取字符串、数组、切片、字典或通道类型的值的长度。
    * var numbers2 [5]int 只声明一个数组类型的变量而不为它赋值，那么该变量的值将会是指定长度的、其中各元素均为元素类型的零值。[5]int{0, 0, 0, 0, 0}

### 切片类型
    * 切片（Slice）与数组一样，也是可以容纳若干类型相同的元素的容器。与数组不同的是，无法通过切片类型来确定其值的长度。
    * 表示切片类型的字面量如 []int；
    * 对一个切片类型的声明可以这样：type MySlice []int，MySlice即为切片类型[]int的一个别名类型。 对切片值的表示也与数组值也极其相似，如：[]int{1, 2, 3}
    * 实施切片操作的方式就是切片表达式。举例如下：
    * var numbers3 = [5]int{1, 2, 3, 4, 5}
    * var slice1 = numbers3[1:4]  切片表达式numbers3[1:4]的求值结果为[]int{2, 3, 4}。实际上，slice1这个切片值的底层数组正是numbers3的值。
    * 在一个切片值上实施切片操作 var slice2 = slice1[1:3]  slice2的值为[]int{3, 4}
    * 作为切片表达式求值结果的切片值的长度总是为元素上界索引与元素下界索引的差值。
    * 一个切片值的容量即为它的第一个元素值在其底层数组中的索引值与该数组长度的差值的绝对值。为了获取数组、切片或通道类型的值的容量，我们可以使用内建函数cap，如：var capacity2 int = cap(slice2)
    * 切片类型属于引用类型。它的零值即为nil。

### 字典类型
    * Go语言的字典（Map）类型其实是哈希表（Hash Table）的一个实现。字典用于存储键-元素对（更通俗的说法是键-值对）的无序集合。注意，同一个字典中的每个键都是唯一的。
    * 字典类型的字面量如下：map[K]T， K”意为键的类型，而“T”则代表元素（或称值）的类型。如： map[int]string。字典的键类型必须是可比较的，否则会引起错误。
    * 以字典类型map[int]string为例，它的值的字面量可以是这样的： map[int]string{1: "a", 2: "b", 3: "c"}
    * mm := map[int]string{1: "a", 2: "b", 3: "c"}  运用索引表达式取出字典中的值，就像这样：b := mm[2] 放入方括号中的不再是索引值，而是与我们要取出的值对应的那个键。
    * e, ok := mm[5] 针对字典的索引表达式可以有两个求值结果。第二个求值结果是bool类型的。它用于表明字典值中是否存在指定的键值对。不存在键5，变量ok必为false
    * 从字典中删除键值对的方法非常简单，仅仅是调用内建函数delete而已，就像这样：delete(mm, 4)
    * 与切片类型相同，字典类型属于引用类型。它的零值即为nil

### 通道类型
    * 通道（Channel）是Go语言中一种非常独特的数据结构。它可用于在不同Goroutine之间传递类型化的数据，并且是并发安全的。 Goroutine（也称为Go程序）可以被看做是承载可被并发执行的代码块的载体。它们由Go语言的运行时系统调度，并依托操作系统线程（又称内核线程）来并发地执行其中的代码块。
    * 通道类型的表示方法很简单，仅由两部分组成，如下：chan T  左边是代表通道类型的关键字chan，而右边代表该通道类型允许传递的数据的类型。
    * 无法用字面量来为通道类型的变量赋值。只能通过调用内建函数make来达到目的。make函数可接受两个参数。第一个参数是代表了将被初始化的值的类型的字面量，而第二个参数则是值的长度。make(chan int, 5)
    * 声明一个通道类型的变量，并为其赋值： ch1 := make(chan string, 5)
    * 可以使用接收操作符<-向通道值发送数据。 ch1 <- "value1"
    * 从ch1那里接收字符串。 value := <- ch1
    * value, ok := <- ch1。这样做的目的同样是为了消除与零值有关的歧义。这里的变量ok的值同样是bool类型的。它代表了通道值的状态，true代表通道值有效，而false则代表通道值已无效（或称已关闭）。
    * 关闭通道值，可以通过调用内建函数close来达到目的，就像这样：close(ch1) 通道值的重复关闭会引发运行时恐慌。这会使程序崩溃。
    * 通道类型属于引用类型。它的零值即为nil
    * 通道有带缓冲和非缓冲之分。缓冲通道中可以缓存N个数据。我们在初始化一个通道值的时候必须指定这个N。相对的，非缓冲通道不会缓存任何数据。发送方在向通道值发送数据的时候会立即被阻塞，直到有某一个接收方已从该通道值中接收了这条数据。
    * 非缓冲的通道值的初始化方法如下：make(chan int, 0)
    * 我们还可以以数据在通道中的传输方向为依据来划分通道。默认情况下，通道都是双向的，即双向通道。如果数据只能在通道中单向传输，那么该通道就被称作单向通道。
    * type Receiver <-chan int 类型Receiver代表了一个只可从中接收数据的单向通道类型。这样的通道也被称为接收通道。
    * type Sender chan<- int  声明一个发送通道类型
    * 单向通道的主要作用是约束程序对通道值的使用方式。比如，我们调用一个函数时给予它一个发送通道作为参数，以此来约束它只能向该通道发送数据。




